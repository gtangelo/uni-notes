# Introduction

## Structure of a Compiler

**Front End** - does analysis which breaks a program into pieces

1. **Scanner** produces tokens
2. **Parser** gives a tree representation (AST)
3. **Semantic Analyser/Type Checker** performs typechecking on the AST and produces a decorated AST
4. **Intermediate Code Generation** i.e. Java byte code instructions

**Back End **- sythesis, take the output from the frontend and put it together in a program consist of machine instructions

5. **Code Optimisation** to improve performance
6. **Code Generation** produce machine instructions to be executed by computer hardware

**1. Lexical Analysis - Scanner**

- groups characters into tokens
- character string forming a token is a lexeme
- eliminates white space (blanks, tabs and returns)

```
position = initial + rate * 60 

becomes...

1. The identifier position
2. The assignment operator =
3. The identifier initial
4. The plus sign
5. The identifier rate
6. The multiplication sign
7. The integer constant 60.
```

**2. Syntax Analysis - Parser**

- groups/reads a sequence of tokens and produces Abstract Syntax Tree
- produces meaningful error messages and attempts error detection/recovery
- **Context-free grammars** (CFGs) are used to describe context-free languages. CFG is a set of recursive rules used to generate patterns of strings and a set of rules that define the syntax of a language.

```
Typical arithmetic expressions are defined as CFG (Context-Free Grammar):
<expr> -> <expr> + <term> | <expr> − <term> | <term>
<term> -> <term> ∗ <factor> | <term> / <factor> | <factor>
<factor> -> ( <expr> ) | ID | INTLITERAL
```

**3. Semantic Analysis**

- Checks the program for semantic errors i.e. variables used before defined, procedures called with the right number and types of arguments
- type checking the AST produced by the parser
- The symbol table will be consulted - keeps track of the variables and declared types to perform type checking
- produces a decorated AST - add extra information (i.e. type information) to the original AST

**4. (Intermediate) Code Generation**

- Use the decorated AST and produces intermidiate code instructions (i.e. byte/assembly code)

**Error Detection, Reporting and Recovery**

- Detection
  - Lexical errors: e.g., ”123 =⇒ unterminated string
  - Syntax Errors: e.g., forgetting a closing parenthesis
  - Semantic Errors: e.g., incompatible operands for an operator
- Report as accurately as possible the locations where errors occur. After detecting an error, can recover and proceed, allowing further errors in the source program to be detected.