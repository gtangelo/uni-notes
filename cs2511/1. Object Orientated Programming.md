# Object Orientated Programming in Java

- create user defined types i.e. classes
- each class contains data (attributes) and methods
- instance of a class is called an **object**
- encapsulates data (attributes) and methods (behaviours) into objects
- Objects have the property of information hiding

## Inheritance

- software reusability - new classes (the subclass) are created from the existing classes (the superclass) by absorbing their attributes and behaviours which they can be modify.

## Relationships

 ### Is-a Inheritance Relationship

- In an "is-a" relationship, an object of a subclass may also be treated as an object of the superclass. i.e. `UndergraduateStudent` can be treated as `Student`.
- Should use inheritance to model as a "is-a" relationship. Don’t use inheritance **unless all or most inherited attributes and	methods make sense**.

### Has-a relationship

- In a "has-a" relationship, a **class object has an object of another class** to store its state or do its work, i.e. it "has-a" reference to that other object.
- "Has-a" relationships are examples of creating new classes by composition of existing classes

## Designing a Class

- keep data private
- consider different ways an object can be created
- always initialise data
- if object is no longer in use, free up all associated resources
- break up classes with too many responsibility
- Classes are often related. Factor out common attributes and methods into a new class. Then, use a 'is-a' or 'has-a' relationships.

### Classes/Objects in Java

**Access Modifiers**

- **Private** - only avaliable in the class, not avaliable in the subclass
- **Protected** - availiable in the class, subclass, package or in other packages
- **Public** - availiable everywhere
- No modifer (Default) - access only in the package

**Keywords**

- **static** - associated to the class, not to the object
  - Using a static method, would not need to create an object/instance to use the method.
  - Otherwise, without `static`, you would need to create an instance to access that method.
- **final** - defined as a constant

**Classes**

- Every class is a subclass to the `Object` class -> `Object` class offers default methods i.e. `this.toString()`

```java
public class Circle {
    static int no_circle = 0;
    public Circle {
        super();		// calls constructor of the super class - constructs class 'Object' instance
        				// 	- java implicitly executes this, so do not need to write
        no_circle++;	// keeps track how many circles were initialised due to 'static' keyword
    }
    public Circle(int x, int y, int r) {
        this();			// initialises the first constructor 'Circle()'
        ...
    }
    public Circle(int x, int y) {
        this(x, y, 5);	// initialises the first constructor 'Circle()'
    }
    
    @Override
    public String toString() {
        ...				// overrides toString method from superclass i.e. class 'Object'
    }
    
    @Override
    public boolean equals(Object obj) {
   
        if(obj == null) { return false; }
        if(obj == this) { return true; }

        if(this.getClass() != obj.getClass()){
            return false;
        }

        Circle other = (Circle) obj;
        if(this.x == other.x && this.y == other.y && this.r == other.r){
            return true;
        }
        else {
            return false;
        }
         
    }
}
```

## Subclasses and Inheritance

**Has-a Relationship**

- **Method Forwarding**: uses methods from the class Circle (area and circumference) to define some of the new methods.

```java
public class GraphicalCircle2 {
	Circle c;
	Color outline, fill;
	
	public GraphicalCircle2() {
		c = new Circle();
		this.outline = Color.black;
		this.fill = Color.fill;
	}
  
  public void setX(int X) {
    c.setX(X) // example of method forwarding
  }
	
	// method using c object
	public void draw(Graphics g) {
		...
		g.drawOval(c.x - c.r ...)
		...
	}
}
```

**Is-a Relationship - Extending a Class**

- define subclass approach

**Casting**

- can cast a subclass to a super class however we can only access attributes and methods available in the super class

```java
GraphicCircle gc = new GraphicCircle();
...
double area = gc.area();
...
Circle c = gc; // we cannot call draw method for “c”.
```

### Single vs Multiple Inheritance

- Java is single inheritance. Some object-oriented languages employ multiple inheritance, where a new class can have two or more super classes.
- In multiple inheritance, problems arise when a superclass’s behaviour is inherited in two/multiple ways (i.e. diamond inheritance problem).
  - ambiguity that **arises when two classes B and C inherit from A**, and class D inherits from both B and C

## Super classes, Objects, and the Class Hierarchy

**`Object` Class**

- Its the only class that does not have a superclass. The methods defined by Object can be called by any Java object (instance).
- Often we need to override the following methods:
  - toString()
  - equals()
  - hasCode()

## Abstract Classes

- we can **declare classes that define only part of an implementation**, leaving extended classes to provide specific implementation of some or all the methods.

- The benefit of an abstract class is that methods may be declared such that the programmer knows the interface definition of an object. However, methods can be implemented differently in different subclasses of the abstract class (i.e. `Shape` is an abstract class for `Circle` and `Square`).

  ```java
  public abstract class Shape {
  	public abstract double area();
  	public abstract double circumference();
  }
  
  public class Rectangle extends Shape {
    ... // overrides abstract methods
  }
  ```

- An abstract class **cannot be instantiated**

- A subclass of an abstract class can be instantiated if it overrides each of the abstract methods of its superclass and provides an implementation for all of them.

  - If a subclass of an abstract class **does not implement all the abstract methods** it inherits, that subclass is **itself abstract**.

- In the example, instantiations of `Circle` and `Rectangle` can be assigned to variables of Shape. No cast is necessary.

  ```java
  Shape[] shapes = new Shape[4];	// array to hold shapes
  shape[0] = new Circle();
  shape[1] = new Rectangle();
  
  total_area = shape[0].area() + shape[1].area();	// can invoke abstract methods
  ```

## Interfaces

- Similar to `.h` files in C - provides type definition and signature - no implementation (Java API)
- similar to abstract classes except:
  - All the methods defined within an interface are **implicitly abstract**.
  - Variables declared in an interface must be **static** and **final**, that means, they must be constants.
  -  Just like a class extends its superclass, it also can optionally **implements** an interface.
  - A class can **implements more than one interfaces**.
  - When a class implements an interface, instance of that class can also be assigned to variables of the interface type.

  ```java
  public interface Drawable {
    public void setColor(Color c);
    ...
  }
  
  public class DrawableRectangle extends Rectangle implements Drawable() {
    // implements methods of interface
    public void setColor(Color c){ ... }
  }
  
  public class DrawableScalableRectangle extends DrawableRectangle implements Movable, Scalable {
    ...
  }
  ```

  -  Interfaces can have **sub-interfaces** - inherits all abstract methods and constants
  - can extend multiple interfaces

  ```
  public interface DrawingObject extends Drawable, Transformable()
  ```

## Method Overriding (Polymorphism)

Polymorphism - an object’s ability to decide what method to apply to itself, depending on where it is in the inheritance hierarchy, is usually called polymorphism.

- Method overriding - change implementation of method in superclass (methods with same name may have more than one signature i.e. how we can define several constructors - overriding occurs on that method with the same function signature)

```java
class A {
	int i = 1;
	int f() { return i; }
}

class B extends A {
	int i = 1;							// shadows i from A
	int f() {								// overrides f() from A
		int i = super.i + 1;	// retrieves i attr from A - use this.i to retrive i attr from B
		return super.f() + 1;	// involes f() from A
	}
}
```

### Method Overloading

Defining methods with the same name and different argument or return types is called **method overloading**. In Java, a method is distinguished by its method signature - its name, return type, and by the number, type, and position of its arguments.

```java
double add(int, int)
double add(int, double)
double add(float, int)
double add(int, int, int)
double add(int, double, int)
```

## Encapsulation

- can hide the data within the class and make it available only through the methods - access modifiers

## Constructors

- If a constructor is not defined in a class, no-argument constructor is implicitly inserted. If a constructor is defined with one or more arguments, no-argument constructor is not inserted in that class.
- If the first statement in a constructor is not a call to super() or this(), call to super () is implicitly inserted.
- A class can have multiple constructors, with different signatures. The word `this()` can be used to call another constructor in the same class.



abstract classes - more like objects

interface - more like actions
